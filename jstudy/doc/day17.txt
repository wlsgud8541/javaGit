# day17

final 속성
	1. final class
		==> 이 클래스는 더 이상 상속이 불가능한 클래스임을 밝히는 속성 
			기능을 추가 하거나 변경하지 말고
			현재 기능 그대로만 사용하라는 의미의 클래스
			
	2. final 함수
		==> 이 함수는 오버라이드가 불가능한 함수
			따라서 이 함수는 매우 중요한 함수이므로
			함부로 기능을 바꾸지 말고 현재 기능 그대로 사용하세요
	
	3. final 변수
		==> 이 변수는 값을 수정 할 수 없는 변수
			즉, 현재 값을 유지해야만 하는 변수
			==> 상수
	
------------------------------------------------------------------------------------------------

추상 클래스
==> 추상 함수를 0개 이상 가지고 있는 클래스
	즉, 추상 함수가 한 개도 없어도 강제로 추상 클래스를 만들 수 있고 
	추상 함수가 1개라도 존재하면 무조건 추상 클래스가 되어야 한다.
	
	--------------------------------------------------------------
	
	추상함수란?
	==> 함수의 몸체({})가 없는 함수를 말한다.
		즉, 기능이 정해지지 않은(없는) 함수를 말한다.
		
	형식 ]
	
		[접근 지정자] abstract 반환값타입 함수이름(매개변수리스트);
		
	예 ] public abstract void abc(int a);	
	
	--------------------------------------------------------------
	
	추상 클래스 만드는 형식
	
	[접근지정자] abstract class 클래스이름{
		[추상함수]
		일반함수
		멤버변수
	}
	
왜???
	다형성 구현을 하기 위해서...
	
	
추상 클래스 사용하는 방법
==> 추상 클래스는 스스로 new 될 수 없다. ( 추살클래스는 new 시킬 수 없다.)
	왜냐하면 그 안에는 기능이 없는 (아직 구현 안된, 실체가 없는) 함수가 존재하기 때문에
	
	방법1 ] 다른 클래스에 상속을 해준 후 
			추상 함수의 기능을 만들어 주고(override)
			하위 클래스(상속 받은 클래스)를 new 시켜서
			추상 클래스의 변수에 기억시켜서 사용한다.
			
			==> 실무에서 이렇게 사용하는 경우는 별로 없다.
	
	방법2 ] 소속 함수 중에 반환값타입이 클래스 자기자신이고 
			속성이 static인 함수를 호출해서 사용하면된다.
					 
		
----------------------------------------------------------------------------------------------------------------------------------

참고 ]
	추상 클래스가 아님에도 불구하고
	생성자 함수가 존재하지 않는 클래스가 있다.
	이 경우 생성자가 없는 것이 아니고
	생성자의 접근 지정자를 private로 감춰 놓은 것이다.
	따라서 new 시켜서 인스턴스를 만들 수 없고
	이런 클래스 역시 
		속성이 static이면서
		반환값 타입이 클래스 자기 자신인
	함수를 찾아서 호출해주면 된다.	 

----------------------------------------------------------------------------------------------------------------------------------

인터페이스(Interface)
==> 클래스의 한 종류이긴 하지만 약간 그 형태나 의미가
	지금까지와는 다른 특수한 클래스의 일종이다.
	
	1. 최상위 클래스가 Object 가 아니다.
		==> 다른 클래스를 상속받아서 만들어진 클래스가 아니다.
		
	2. 내부에는 100% 추상함수가 존재해야 한다.
		==> 절대로 일반함수(몸체가 있는 함수)는 존재하지 않는다.
			==> 기능을 가지고 있는 함수는 절대로 존재하면 안된다.
			
	   참고 ] 
	   		인터페이스에서는 함수를 정의를 할 때
	   		abstract 라는 속성을 부여하지 않아도
	   		자동적으로 public abstract 속성이 부여된다.
	   		
	   		- 추상함수 원래 형식 : public abstract 반환값타입 함수이름(매개변수리스트);
	   		- 인터페이스에서 형식 : 반환값타입 함수이름(매개변수리스트); ==> 이 경우는 앞에 public abstract 가생략된 경우
	   		
	3. 인터페이스는 다른 클래스에 상속해 줄 수 있는데 다중 상속이 가능하다.
	
	4. 변수는 가질 수 있다. 이 변수들은 묵시적으로 'public static final 변수'가 된다.
	
	5. 인터페이스 소속 함수는 묵시적으로 public 함수가 된다.  		
	
	참고 ]
		인터페이스 내에 일반함수(몸체가 있는 함수)를 사용 할 수 있다.
		이 경우에는 반드시 함수의 속성을
			default
		라고 명시해야 한다.
		
		형식 ]
			default 반환값타입 함수이름(매개변수리스트){
				함수내용
			}
	
	
	
인터페이스 제작 방법
	[접근지정자] interface 인터페이스이름 {
		public static final 타입 변수이름 = 데이터;
		
		[public abstract] 반환값타입 함수이름(매개변수리스트); 
	}

만들어 놓는 이유
==> 가끔은 JVM에 의해서 자동 호출되어야 하는 함수가 필요하다.
	따라서 함수의 존재는 필요하지만 그 함수가 해야 할 일을 개발자가 정해야 할 경우가 있다.
	따라서 기능은 개발자의 몫으로 남긴 것이다.

인터페이스 사용 방법
	
	1. 1) 인터페이스는 스스로 new 될 수 없다.
	   		==> 추상 클래스와 마찬가지로 내부에 기능이 정의 되어있지 않은 함수가 존재하기 때문이다.
	   			따라서 일반 클래스에 상속 해준 후 그 클래스를 new 시켜서 사용해야 한다.
	   			
	   			상속 해주는 방법 ]
	   				[접근지정자 [속성] class 클래스이름 implements 인터페이스{
	   					추상함수오버라이드
	   				}  
	   
	   	   참고] class를 상속 받는 것은 '상속' 이라고 표현하고
	   	   		 interface를 상속 받는 것은 '구현' 이라고 표현한다.
	   
	   2) 상속 받은 클래스에서는 인터페이스 안에 있는모든 함수를 100% 오버라이드해야 한다.
	   		==> 내용을 정하지 못할 경우에는 블럭만이라도 구현해야한다.
	   	
	   	  인터페이스 소속함수의 접근 지정자는 public 이다.
	   			 
	   3) 구현한 일반 클래스를 new 시켜서 사용한다.
	   		==> 이 방법이 인터페이스를 사용하는 90%를 차지
	   		
	2. 약 10% 정도는 추상클래스와 같은 방법으로 사용하면 된다.
	   함수 중 속성이 static이면서 반환 값 타입이 자기자신인 함수를 호출해서 사용하면된다.
	   인터페이스의 경우 이런 함수를 자기자신이 가지지 않고
	   다른 클래스에 이런 함수가 존재하기 때문에 찾아서 사용해야 한다.
	   
	   참고 ] 인터페이스는 다중상속이 가능하다.
	   
	   형식 ] 
	   			class 클래스이름 implements 인터페이스1, 인터페이스2, ... {
	   				인터페이스들이 가진 추상함수는 모두 오버라이드 해야한다.
	   			}		
	   			
	   참고 ] 일반 상속과 인터페이스 구현을 동시에 사용 할 수 있다.
	   		  단, 일반 상속이 먼저 기술되어야 한다.
	   		  
	   형식 ] 
	   		  class 클래스이름 extends 상속해줄클래스 implements 인터페이스1, 인터페이스2, ...{
	   				추상함수는 모두 구현(오버라이드)되어야한다.
	   		  }		  			

		참고 ] 인터페이스는 다른 인터페이스를 상속 받아서 만들 수 있다.
		
				형식 ] 
					interface 인터페이스이름 extends 인터페이스{
					}
				주의 ]
					인터페이스를 상속받아서 인터페이스를 만드는 경우는 implements 가 아니고 extends 이다.	


----------------------------------------------------------------------------------------------------------------------------------		























































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	