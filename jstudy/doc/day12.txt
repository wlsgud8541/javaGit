# day12

참고 ]
	다차원 배열의 경우
	내부의 배열의 길이는 모두 달라도 된다.
	
	형식]
	
		int[][] arr = new int[5][];
		
		arr[0] = {1,2,3};
		arr[1] = {1,2,3,4,5};
		arr[2] = {10};
		arr[3] = {11,12,13,14};
		arr[4] = {21,22};


-------------------------------------------------------------------------------------------------------------------------------
배열의 단점]
	1. 한 번 배열의 크기가 정해지면 크기 조절이 불가능하다.
		예]
			int[] num = new int[10];
			==> num 이라는 배열을 만드는데
				이 배열은 정수 10개를관리할 배열입니다.
				
				이때 데이터가 한개 더 추가되어야 한다면
				위에서 만들어 놓은 배열로는 작업이 불가능하다.
				
				따라서 다시 추가될 갯수만큼의 배열을 만들어서 관리해야한다.
				
				num = new int[11];
				
				의 작업으로 배열을 다시 만들고
				깊은 복사로 기존 데이터는 복사해서 사용해야한다.
				
				System.arraycopy(tmp, 0, num, 0, 10);
				num[10] = 100;
				
	2. 같은 타입의 데이터만 관리 할 수 있다.	
		==> 주소는 Heap타입에 의해서 결정되고
			Heap타입이 다르면 사용 할 수 없다.
	
			int[] no;
			
			no = new float[10];
			no = new String[10];
			==> Heap 타입이 다르기 때문에 변수가 인스턴스의 주소를 기억 할 수 없다.
	
	<== 배열만드는 형식]
			데이터타입[] 변수 = new 데이터타입[갯수];
			
			==> 배열은 만들때
				관리할 데이터의 타입과 갯수가 정해져야된다. 
				
				
-------------------------------------------------------------------------------------------------------------------------------				
String 배열

	참고 ] String 역시 주소 변수
		   
		   String str = "jennie";
		   라고하면
		   
		   str에는 리터럴풀의 데이터의 주소가 기억된다.
		   
		   String str1 = new String("jennie");
		   라고하면
		   str1에는 Heap 만들어진 String의 인스턴스의 주소를 기억하고
		   그 인스턴스에서 리터럴 풀의 주소를 참조하게 된다.
		   
		   참고]
		   		레퍼런스 변수란??
		   		==> 인스턴스의 주소를 기억하는 변수
		   			하지만 프로그램에서는 주소는 필요 없다.
		   			오직 데이터만 필요할 뿐이다.
		   			따라서 주소 변수는 데이터가 존재하는 위치를 알려줄 뿐이고
		   			핵심은 데이터가 들어감 메모리, 실제 데이터가 중요하다.
		   
		   
		   - String 배열 만들기
		   	
		   		String[] 변수이름;	==> 변수 선언
		   		변수이름 = new String[갯수]; ==> 배열이 관리할 데이터의 공간만 확보한 상태 
		   		
		   		==> 따라서 지금 상태는 배열의 각 방에 인스턴스가 채워져 있지 않은
		   			아무것도 정해지지 않은 상태이다.
		   			
		   			문자열 배열의 경우는 데이터를 바로 대입해 줄 수 있기 때문에
		   			각 방에 접근해서 문자열을 대입해주면 사용가능한 상태가 된다.
		   			
	   			String 배열도 초기화가 가능하다.
	   			
	   			예] 
	   				String[] pink = {"제니", "리사", "로제", "지수"};
	   				String[] pink = new String[]{"제니", "리사", "로제", "지수"};
		   
		   
-------------------------------------------------------------------------------------------------------------------------------					   
참고 ]
	String은 필요에 따라서 char[] 형태로 변환해서 사용 할 수 있다.
	
	사용 함수 ]
		문자열.toCharArray();
		
	예]
		String name = "jennie";
		char[] jeny = name.toCharArray();
			   
		jeny[0] ==> 'j'
		jeny[5] ==> 'e'
		
	
	참고 ]
		String 클래스에서 자주 사용되는 함수
		
			1. charAt(위치값) ==> 해당 위치의 문자를 반환해주는 함수
			2. length()		  ==> 문자열의 길이를 반환해주는 함수
			3. substring()	  ==> 문자열 중에서 원하는 문자열만 추출해서 반환해주는 함수
		   
		   
		   형식 1]
		   		substring(시작위치)
		   		==> 시작위치에서부터 문자열의 끝까지 추출
		   		
		   형식 2]
		   		substring(시작위치, 종료위치)
		   		==> 시작위치에서부터 종료위치 이전까지 추출
		   		
		   참고 ] 시작위치는 0부터 시작하고
		   		  종료위치는 1부터 가운트해서 지정 할 수 있다.
		   		  
		   
		   4. equals()		  		
		   	  ==> 문자열의 데이터가 같은지 비교해주는 함수
		   	  	  
		   	  	  형식 ]
		   	  	  		문자열1.equals(문자열2)
		   	  	  		==> 반환값은 논리형(true, false)로 반환된다.
		   	  	  		
		   	  	  		
-------------------------------------------------------------------------------------------------------------------------------		
2차원 배열
==> 1차원 배열을 다시 배열로 관리하는 것

2차원 배열 만드는 방법
	1. 배열의 주소를 기억할 변수를 만든다.
		==> Heap 영역에 배열이 만들어질 것이고
			Heap 여역에 있는 데이터는 주소를 알아야 사용 할 수 있기 때문이다.
			
			방법 ]
			
				데이터타입[][] 변수;
				==> []를 하나만 스면 1차원 배열
					[][] 이렇게 두개를 사용하면 2차원 배열이 된다.		   	  	  		
		   	  	  		
		   	  	  		
		   	  	  		
	2. 1차원 배열을 몇개를 관리할지를 결정하고
	   1차원 배열의 주소를 기억할 메모리를 만든다
	   
	   		방법 ] 
	   		
	   			변수 = new 데이터타입[갯수][];
				==> 갯수는 1차원 배열의 갯수를 의미한다.
				
				예] nums = new int[2][];
					==> 인스턴스는 주소를 기억해야만 접근해서 사용 할 수 있기 때문이다.
	
	
	3. 실제 데이터를 기억 할 1차원 배열을 만들어 준다.			
			
			방법 ]
				변수[위치값] = new 데이터타입[갯수];
				
				예 ] 
				nums[0] = new int[5];
				==> 만들어진 1차원 배열도 주소를 알아야 접근해서 데이터를 사용 할 수 있으므로
				그 주소를 배열의 배열을 관리할 공간에 기억시킨다.	
						   				   
	
	참고 ] - Heap Type
				==> 그 주소가 가르키는 곳에 있는 데이터의 형태를 지정하는 용어
					인스턴스는 Heap에 만들어진다.
				==> 같은 Heap Type 끼리만 사용 가능하다.
				==>	차원 역시 같아야 한다.
			
				int[] no = new int[5];
				==> Heap Type은 no라는 변수의 주소가 가리키는 곳의 인스턴스의 형태는 1차원 배열이다.
					즉, Heap Type은 1차원 정수 배열이 된다.
					
		   - 사각형 형태의 배열도 만들 수 있다.
		   	 
		   	 형식 ]
		   	 	데이터타입[][] 변수 = new 데이터타입[갯수1][갯수2];
		   	 	==> 데이터베이스의 테이블로 비유하자면 
		   	 		갯수1은 행에 해당하고 갯수2는 컬럼에 해당할 것이다.
		   	 		
		   	 예] int[][] no = new int[3][5];
		   	 	 ==> 3행짜리 5열의 데이터를 가지는 사각형 형태의 배열
		   	 	 
		   	 참고 ] - 사각형 모양이더라도 내부적으로는 위의 방식처럼 주소만 기억하는 것으로 처리된다.
		   	 		
		   	 		- 2차원 배열도 초기화가 가능하다
		   	 	 		방법 ] 
		   	 	 			int[] num = {}; // 1차원 배열 초기화
		   	 	 			int[][] no = {{1,2,3},{4,5,6},{7,8}};
		   
		   			- 여기서도 배열의 갯수는 지정 할 수 없다.
		   			  1차원 배열과 마찬가지로 초기화 데이터의 개수를 이용해서
		   			  자동으로 크기가 결정되기 때문이다.
		   
	2차원 배열의 사용방법
	==> 앞에서부터 [] 안에 위치값을 입력해서 접근하면된다.
	
	int[][] no = new int[3][5];
	
	==> 두번재 배열의 첫번재 데이터를 100 변경하세요
		no[1][0] = 100;	   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		    				
				
				
				
				
				
				
				
				
				