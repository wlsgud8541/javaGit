# day16

상속
==> 이미 만들어져 있는 클래스의 기능을 그대로 부여 받아서
	(변수와함수의 기능을 그대로 복사해와서)
	새로운 클래스를 만드는 방법
	
	생겨난 이유?
	==> 소프트웨어의 개발 속도를 빠르게 하기 위한 방법의 한 가지
	
		즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것
		
		객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
		그 부품을들을 조립해서 원하는 결과를 만들어 가는 것.
		
		어딘가에서 부품(클래스)를 구했는데
		그 기능이 사용자 마음에 꼭 맞지는 않을 수 있다.
		
		따라서 처음부터 다시 만들어야 하나?라는 문제에 도달 한다.
		이 문제를 해결하기 위해서 만든 방법이 상속이다.
		
		상속은 자신이 만들고자 하는 부품과 가장 비슷한 부품을 가지고 와서
		일단 그 기능을 모두 복사한 후
			1. 없는 기능은 추가하고
			2. 있는 기능 중 바꿀 내용은 바꾸고
		해서 작업해 나가는 것이 상속이다.
		
		상속을 하는 형식 ]
		
			[접근 지정자] [속성] class 클래스이름 extends 상속받을클래스이름{
				현재클래스에서는 상속 받을 클래스가 가진 모든 기능은 이 내부에 복사되어있다.
			}
		
		참고 ] 자바는 오직 단일 상속만 허락한다.
			   즉, 상속은 오직 한 개의 클래스에서만 받을 수 있다.
			   
			   예 ]
			   		class NewClass extends OldClass01 <== 가능	
			   		=======================================================================
			   		class NewClass extends OldClass01, OldClass02, OldClass03{} <== 불가능
		
		용어 ]
			1. 상속을 해준 클래스		- super Class, 상위 클래스(부모 클래스)
			2. 상속을 받은 클래스		- sub Class, 하위 클래스(자식 클래스)
			
			3. is a						- 상속 관계에 있는 클래스를 부르는 용어
			
				예] 
					
					class Father{
					}
					
					class Son extends Father{
						
					}
				
					이 경우 Son is a Father 가 성립한다.
					
						
			4. has a 					- 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			
				class Wook{
				
				}
				
				class Class15B{
					Wook w = new Wook();
				}				
				
				Class15B has a Wook 이 성립한다.
				
-------------------------------------------------------------------------------------------------------------
		
상속 관계에 있는 경우 생성자의 역할

	결론적으로
		하위 클래스가 생성되는 순간
		(인스턴스가 만들어지는 순간 - new 명령과 함께 생성자가 호출되는 순간)
		상위 클래스의 인스턴스가 자동 생성된다.
			==> 생성되는 순간 생성자 함수가 호출되므로
				결국 하위 클래스를 생성하면
					상위 클래스의 생성자 함수도 같이 호출된다.
					
		결국 상위 클래스의 생성자 함수는 자동으로 호출되는 개념이다.
		자동 호출 되는 경우에는 무조건 기본 생성자만 이용하게 된다.			
				
	***
	참고 ] super()
			==> 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 함수
			
			특징]
				1. 반드시 생성자 함수 안에서만 호출 할 수 있다.
				2. 반드시 생성자 함수 내의 첫 줄, 첫 문장으로 호출되어야 한다.


	참고 ] 
		super - 현재 실행중인 객체의 상위 클래스의 인스턴스를 기억하는 변수
					==> 현재 클래스의 객체가 생성되는 순간
						상위 클래스의 인스턴스도 자동 생성되기 때문에 
						그 인스턴스의 주소도 기억되어진다.

------------------------------------------------------------------------------------------------------------

*****
함수의 오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위 클래스에서
	상위 클래스가 가진 함수의 기능을 수정하는 행위
	
	방법 ] 
		0. 상속을 받아야한다.
		1. 상위 클래스가 가진 함수의 원형(prototype)과 동일한 형태로 만들어야 한다.
			
			참고] 함수의 원형 => 반환값 + 함수이름 + 매개변수리스트
			
			예]
				public String toString(){} ==> Object 클래스의 멤버
				
				이 함수를 재정의 하는 방법	
				==>
			
			  =============오버라이딩==============
					public String toString(){
						내용을 수정
					}	
			  =====================================		
					==> 오버로딩 O
					
		---------------------------------------------------		

			  ==============오버로딩===============
					public String toString(Object o){
						내용을 수정
					}	
			  =====================================		
					==> 오버라이딩 X / 오버로딩 O
					
					
		2. 접근지정자는 같거나 넓은 방향
			참고 ] 
				클래스에 사용가능한 접근지정자는
					public , 생략
				만 사용 가능
					
		3. 예외전이는 같거나 좁은 뱡향
		
	이렇게 오버라이딩(함수의 재정의)을 하면
	내부적으로 super(상위클래스)의 함수는 숨겨지고 재정의한 함수를 사용하게 된다.
	
	예]
		class Father{
			void abc(int no){
				
			}
		}
		
		class Son extends Father{
			void abc(int no){
				// 코딩 내용을 다르게 작성
				// ==> 기능이 변경됨
			}
		}
				
					
					
	super
	==> this가 실행중인 자신의 주소를 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나이다.
		자신의 상위 클래스의 주소가 기억된 변수
		
		사용 목적 ]
			반드시 소속을 밝혀야 하는 경우가 발생할 때 사용한다.
			
------------------------------------------------------------------------------------------------------------
							
객체 지향 언어의 특징
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화					
					
------------------------------------------------------------------------------------------------------------

*************
디형성
==> 하나의 변수를 이용해서
	여러 형태의 클래스를 사용하도록 하는 기법			
	
	주소의 형변환(Casting)
	==> 원칙적으로 주소는 다른 형태로 형변환이 불가능하다.
		즉, 주소는 Heap Type에 따라 주소가 결정되므로
		Heap Type이 다르면 주소는 기억 시킬 수 없다.
		
		예]
			int[] a = new float[5];  -- X
heap type :   int[]         float[]		
					
			float[]	a = new int[5];	 -- X
			
			
	*****
	한 가지 경우에 한해서 주소의 형변환이 가능하다.
	상속 관계에 있는 클래스들 끼리는 형변환이 가능하다.
	왜??
		is a 관계이기 때문에
		==> 하위 클래스에는 상위클래스의 멤버가 들어있기 때문에					
					
		자동 형변환
		==> 하위 클래스의 주소가 상위 클래스의 변수에 기억될 때는 자동 형변환을 해준다.
		
			예 ]
				class Grand {}
				
				class Father extends Grand{}
				
				class Son extends Father{}
				
				Grand g = new Son();
				Father f = new Son();
				Grand g = new Father();
				
		강제 형변환			
		==> 상위 클래스의 주소가 하위 클래스 변수에 기억되는 것은 원칙적으로 불가능하다.
			다만 상속관계에 한해서는 강제로 형변환을 할 수 있다.
			but 안쓰는 걸 추천
			
			예 ] 
				Son s = (Son)new Father();			
					
					
		정리 ]
			다형성이란
			주소의 형변환 이론을 기반으로 해서
			상위 클래스의 주소를 이용해서 하위 클래스를 이용 할 수 있으며
			상위 클래스의 주소를 이용하면 여러 하위 클래스를 사용 할 수 있게 된다.			
					
					
		참고 ]
			개발자 입장에서의 다형성
			상위 클래스의 변수를 이용하면 하위 클래스를 사용 할 수 있다.
			라는 것이 되므로
			상위 클래스의 변수를 이용해서 
			하위 클래스를 받아서 사용하면 된다.			
					
			참고 ] 
				1. 어떤 함수가 상위클래스를 매개변수로 가지고 있으면
					
					예] void abc(Figure f){
					}		
					
					==> 
					abc(new Semo()); // Figure f = new Semo(); // 자동 형변환
					abc(new Won());
					abc(new Nemo()); 
				
					참고 ] 
						매개변수
						
						void xyz(int a){}
						
						xyz(10); ==> int a = 10; 내부적으로 이렇게 처리해서 실행된다.
						
						xyz('A') ==> int a = 'A';
			
			따라서 만약 어떤 함수가 Object 를 매개변수로 가지고 있으면
			Object를 주는 경우는 없다.
			대신 자바에서 사용 할 수 있는 모든 데이터를 입력해도 된다. 라는 결론에 이른다.
			
			
				2. 어떤 함수가 상위 클래스를 반환값 타입으로 가지고 있으면
				반드시 원하는 하위 클래스 타입으로 강제 형변환해서 사용해야한다.
			참고 ]
				Wrapper Class
				==> 객체가 아닌 기본 데이터 타입을 객체처럼 사용해야 될 경우가 발생하기 때문에
					자바에서 기본 데이터 타입을 객체 형태로 사용 할 수 있따록 만들어 놓은 클래스들
				
					종류]
						Boolean
						Character
						Byte
						Short
						Integer
						Long
						Float
						Double		
									
					
				참고 ]
					Boxing
						==> 기본 데이터 타입을 객체 타입으로 변환하는 작업
					
					UnBoxing
						==> 객체 타입을 기본 데이터 타입으로 변환하는 작업
						
					참고 ]
						컬렉션에 모아서 사용 할 데이터의 타입을 정할 수 있는데
						이때는 기본 데이터 타입을 기술하면 안된다.
						이때는 Wrapper Class 타입으로 기술해야 한다.
						
						ArrayList list = new ArrayList();				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						   			