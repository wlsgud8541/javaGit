# day07

3. switch ~ case
	==> 다중 조건 처리 명령
		여러개의 조건을 차례로 처리 할 수 있는 조건 명령
		
		형식 ]
			switch(변수 또는 연산식){
				case	데이터1:
					실행내용1
					break;
				case	데이터2:
					실행내용2
					break;
				...
				default:
					처리내용n
			}
			
		의미 ] 변수 또는 연산식이
						데이터1과 같으면 실행내용1 을 실행하고
						데이터2와 같으면 실행내용2 를 실행하고
						...
						그 이외의 내용이면 처리내용n을 실행하세요.
		
		*****				
		참고 ] 	
			1. 비교방식은 묵시적으로 동등비교(==) 처리를 한다.
				( ==> 크다, 작다 의 대소비교는 할 수 없다.)
				
			2. 앞 case 에서 참이더라도 다음 case를 질문하게 된다.
				==> 그러므로 반드시 break명령을 사용해야 한다.
			3. 앞 case와는 묵시적으로 or연산을 한다.	
			
			참고 ]
				break 명령
				==> switch 명령과 for, while, do~ while, forEach등과 같은 반복문에서만 사용되는 명령
					해당 명령의 block을 벗어나도록 (명령을 즉시 중지시키도록) 하는 명령
			
-------------------------------------------------------------------------------------------------------------------------------------------

반복 제어 명령
	
	while 명령
		==> 조건식을 제시한 후 
			그 조건이 참이면 지정한 내용을 반복하도록 하는 명령
			
			형식 ] 
				(1)
				while(조건식(2)){
					실행내용(3)
				}
				(4)

			실행순서 ] 1 -> 2(조건식이 참이면) -> 3 
					        -> 2(조건식이 참이면) -> 3
					          -> 2(조건식이 참이면) -> 3
					            -> ...
					           	  -> 2(조건식이 거짓이면) -> 4

			참고 ] 1. 이 명령은 선조건 처리명령이다.
					    ==> 최악의 경우(처음 조건이 false인 경우) 실행내용을 한번도 실행하지 않을 수 있다.
				   
				   ***	    
				   2. while 명령은 횟수를 제어 할 카운터 변수가 형식에 들어있지 않다.
				   	  따라서 횟수를 제어하려면 카운터 변수를 먼저 만들어 놓고 블럭내부에서 증감해서 처리해야 한다.	
				
-------------------------------------------------------------------------------------------------------------------------------------------

do ~ while 반복문
==> 후 조건 처리 명령으로
	최악의 상황이더라도 최소 한번은 실행내용을 실행한다.
	
	형식 ]
	
	(1)
	do{
		실행내용(2)	
	}while(조건식(3));
	(4)
	
	실행순서 ] 1 -> 2 -> 3(참)
					 -> 2 -> 3(참)
					 	 -> 2 -> 3(참)
					 	 	...
					 	 		 -> 2 -> 3(거짓)
					 	 		 	 -> 4
					 	 		 	 
					 	 		 	 	
-------------------------------------------------------------------------------------------------------------------------------------------
for 명령
==> while과 마찬가지로 특정 조건이 참이면 반복하도록 하는 명령

	차이점 ] 형식 내부에 횟수를 제한할 카운터 변수를 만드는 것과 제어하는 부분이 포함되어있다.

	형식]
		(1)
		for(카운터 변수 선언 및 초기화(2); 조건식(3); 증감식(4){
			실행내용(5)
		}
		(6)

	실행순서 ] 
		[1 -> 2 -> 3 -> 참 -> 5 -> 4 -> 3 -> 참 -> 5 -> 4 -> ... -> 3 -> 거짓 -> 6]

		[1 -> 2 -> 3 -> 거짓 -> 6]


	참고 ] - (2) 부분은 오직 한번만 실행한다. 따라서 주로 카운터 변수를 초기화 하는 목적으로 사용한다.
		   - (4) 부분은 반복 횟수만큼 동일한 횟수로 반복한다. 따라서 주로 카운터를 증감 시키는 목적으로 사용한다.
		   - for 명령도 마찬가지로 선조건 처리 명령이다.	
				 ==> 최악의 경우 한번도 실행내용을 실행하지 않을 수 있다. 따라서 조건식을 잘 만들어야한다.
		   - for(;;) 안의 내용은 필요하지 않으면 생략해도 무방하다. 만약 두번째 부분이 생략이 되면 항상 true로 파정해서 처리한다.
		   
		   - 지역변수 
		   		==> 해당 변수가 만들어진 블럭(장소)에서만 사용할 수 있는 변수	 
					
					변수는 Stack에 만들어진다.
					이 영역은 가장 작은 영역 중 하나로
					많은 데이터를 한번에 보관하기 힘들고
					따라서 해결방법이
						==> 변수를 만들어 달라고 요청하는 순간 변수를 만든다.
							
							int num; // 이 순간 변수가 만들어진다.
							
							그 변수가 만들어진 영역({})을 벗어나면 자동 소멸되도록 되어있다.
							
		   - 전역변수
		   		==> 클래스내의 어느곳에서든지 사용 할 수 있는 변수				
	
	주의 ] for(int i = 0; ;){
				
		   }				
				
		   이때 변수 i는 for 명령의 영역({})에 속한 지역 변수가 된다.
		   왜냐하면 {}의 의미가 for 명령의 실행범위이므로 for 명령에 속한 모든 변수는 {} 안에 있는 것으로 간주한다. 
		   
	참고 ] 중첩 for 명령
			==> for명령 안에 다시 for 명령을 사용 할 수 있다.
			
				**
				안쪽 for명령은 바깥 for명령이 반복되면 처음부터 다시 실행된다.
				
				예] for(int i = 0(1); i < 3(2); i++(3)){
						실행부분1 (4)
						for(int j = 0(5); j < 5(6); j++(7)){
							실행부분2(8)
						}
						(9)
					}
					(10)	   		

					실행순서 ] 
					
					i 1회차(i==0)
				============================================================================================================
						j 1회차(j==0)
					  ----------------------------------------------------------
						1  ->  2  ->  4  ->  5  ->  6  ->  8  ->  7  ->  6  ->     
					   i==0                 j=0				     j==0   j==1
					  	j 2회차(j==1)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==1   j==2
					  	j 3회차(j==2)
					  ----------------------------------------------------------					   										     
														   8  ->  7  ->  6  ->     
					   										     j==2   j==3
					  	j 4회차(j==3)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==3   j==4
					  	j 5회차(j==4)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->  9  ->  3  ->  2  ->  4  ->     
					   										     j==4   j==5		 i==0   i==1	
					i 2회차(i==1)   										     
				============================================================================================================   										     	   										     					   										     
					  	j 1회차(j==0)
					  ----------------------------------------------------------
										 ->  5  ->  6  ->  8  ->  7  ->  6  ->     
					   		                j=0				     j==0   j==1
					  	j 2회차(j==1)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==1   j==2
					  	j 3회차(j==2)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==2   j==3
					  	j 4회차(j==3)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==3   j==4
					  	j 5회차(j==4)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->  9  ->  3  ->  2  ->  4  ->     
					   										     j==4   j==5		 i==1   i==2	
					i 3회차(i==2)   										     
				============================================================================================================  					   										     
					  	j 1회차(j==0)
					  ----------------------------------------------------------
										 ->  5  ->  6  ->  8  ->  7  ->  6  ->     
					   		                j=0				     j==0   j==1
					  	j 2회차(j==1)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==1   j==2
					  	j 3회차(j==2)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==2   j==3
					  	j 4회차(j==3)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->     
					   										     j==3   j==4
					  	j 5회차(j==4)
					  ----------------------------------------------------------
														   8  ->  7  ->  6  ->  9  ->  3  ->  2  ->  10    
					   										     j==4   j==5		 i==2   i==3	
					   										     
					   										     
					   										     
---------------------------------------------------------------------------------------------------------------------------------------------
flag 기법
==>	우리가 프로그램을 실행하다보면
	두 가지 이상의 경우가 발생되는 순간이 존재한다.
	그 후에 어떤 경우가 발생했는지를 알아보는 기법
	
	예]
		for(;;){
			break; // 이 명령이 실행되면 (1) 부분으로 진행한다.
		}				   										     
		(1)
		==> 부분은 for 명령이 정상적으로 종료된 후에 실행되는 부분
			
			문제는 (1) 부분을 실행할 때 정상적으로 반복해서 종료되었는지 
			아니면 중간에 break 명령에 의해서 종료가 되었는지를 확인해야 되는 경우가 있다.
			
			확인방법 ]
				반복문이 시작하기 전에
					1. 변수를 만들어두고 특정 데이터도 초기화 해둔다.
					2. 특정 순간이 발생(break 상황)하면 변수의 데이터를 변경한다.
					3. 반복문이 종료된 후 만들어둔 변수의 내용만 확인하면 된다.
					
					
					
					
					
					
					
					
				
			
			