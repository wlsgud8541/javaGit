# day20

1. 부서번호를 입력하면
	해당 부서 소속의 사원들의
		사원번호, 사원이름, 직급, 급여
	를 조회하는 기능	
	
	제어하는 기능 추가
		1. 이름으로 조회
			--> 이름 리스트 출력
			--> 이름 입력창 실행
			--> 입력받은 이름으로 데이터 조회
			
		2. 부서번호로 조회
			--> 부서번호 리스트 출력
			--> 부서번호 입력창 실행
			--> 입력받은 부서번호로 데이터 조회
			
		3. WOOYOUNG 사원 입사정보 입력
		
			- 사원번호 : 서브질의
			- 사원이름 : WOOYOUNG
			- 직    급 : MANAGER
			- 상사번호 : SMITH 사원번호
			- 입 사 일 : 오늘날짜(시간제외)
			- 급    여 : 500
			- 커 미 션 : -500
			- 부서번호 : SMITH 부서번호
			- 메    일 : wooyoung@githrd.com 
			
		4. WOOYOUNG 사원의 급여를 501로 수정하기
	
	
숙제 ] 
	4번 기능을 
		1. 이름을 입력하면 이름에 해당하는 사원들의
			[사원번호, 사원이름, 급여, 입사일, 부서번호]
		   를 출력해주는 기능을 추가
		 
		2. 출력된 사원의 사원번호와 급여를 입력해서
		   사원의 급여를 수정해주는 기능을 구현.   	
	
	
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Set 계열
==>
	특징 ]
		1. 입력순서를 보장하지 않는다.
			==> 나름의 규칙을 가지고 내부적으로 정렬을 해서 보관한다.
			
		2. 중복데이터를 허용하지 않는다.	
			==> 같은 데이터가 다시 저장되면
				먼저 데이터는 지우고
				새로운 데이터를 입력한다.
	
	
		***
		Set 계열은 데이터의 위치를 개발자가 알 수 없으므로
		데이터를 꺼내는 함수가 존재하지 않는다.
		따라서 기억된 데이터를 추출하려면
			Iterator 또는 List계열
		로 변환해서 순차적으로 꺼내서 사용해야 한다.	
					
	종류 ]
		1. HashSet
			==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
				따라서 우리가 상상하는 정렬은 이루어 지지 않는다.
				
				참고 ] HashSet(int initialCapacity, float loadFactor)
					   loadFactor : 해쉬코드값을 만드는 규칙에 사용 할 상수 값을 사용자가 지정해서 해쉬테이블을 만들어서 사용한다. 
			
		2. TreeSet
			==> 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션
				
				특징 ]
					우리가 상상하는 정렬 방식을 이용한다.
					
					***
					정렬가능한 객체들만 기억 할 수 있다.
					
				생성자 ]
					TreeSet(Comparator comparator)	
					==> 정렬방식을 지정해서 TreeSet을 만든다.
					
					TreeSet(SortedSet<E> s)
					==> TreeSet을 이용해서 다시 TreeSet을 만드는 방법
					
				참고 ]
					subSet()
						==> 하나의 Set에 담긴 내용 중에서 특정 부분만 골라서 새로운 Set을 만드는 함수
						
					headSet(E toElement)
						==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다.
					
					tailSet(E fromElement)	
						==> 지정한 부분부터 마지막까지 골라서 새로운 Set을 만든다.
	
	
-------------------------------------------------------------------------------------------------------------------------------------------

Map
==> 하나의 데이터를 그 데이터를 구분 할 수 있는
	키값과 한쌍으로 만들어서 데이터를 기억하는 컬렉션
	따라서 사용할 경우에는 키 값을 이용해서 데이터를 꺼낼 수 있도록 해놓았다.
	
	Map 계열은 많은 양의 데이터를 보관하는 용도 보다는
	데이터를 손쉽게 구분하여 사용할 목적으로 사용된다.
	
HashMap / Hashtable
==>
	Hashtable은 이전 버전이고
	HashMap이 나중 버전이다.
	따라서 HashMap의 사용을 권장하고있다.
	
	내부적으로 키값을 해쉬 테이블을 이용해서 정렬해서 보관한다.
	
	주요함수 ]
		put(Object key, Object value);
			==> 데이터 입력 함수
			
		get(Object key);
			==> 데이터 출력 함수
		
	참고함수 ]
		values();
			==> 데이터들만 꺼내는 함수
			
				예 ]
					HashMap map = ...;
					
					Collection col = map.values();
					
					1번 방법) Iterator itor = col.iterator();
					
					2번 방법) ArrayList list = new ArrayList(col);
					
				
		keys(); / ketSet();
			==> 키값들만 꺼내주는 함수
			
			Enumeration<K> keys()
			참고 ]
				Enumeration : Iterator의 구버전 / 데이터를 순차적으로 꺼내서 사용해야한다.
		
			Set<K> keySet()
				==> 키값들만 추출해서 Set으로 반환해주는 함수 
			
			참고 ]
				1. HashMap에는 키 값만 추출하는 함수가 keySet()만 있다.
				
		entrySet(); 	
			==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
				(위의 함수를 사용하면 다른 방법으로도 꺼낼 수 있긴 하다.)
				==> 키값과 데이터를 VO(Map.Entry)에 담아서 Set으로 묶어주는 함수
					
					Set<Map.Entry> ==> Set<VO> ==> VO : key, value 변수와 getters & setters 함수만 가지고 있다.
		
					HashMap map = new HashMap();
					
					map.put("won", 1);
					map.put("two", 2);
					map.put("three" , 3);
		
		
					Map.Entry
					==>
						VO {
							private Object key;
							private Object value;
							...
						}
			
			==>
				Map 은 항상 키와 벨류가 있어야 저장된다.
				Set 은 오직 한개만 저장 할 수 있다.
				따라서 키와 벨류를 하나로 묶어야만 Set에 기억 시킬 수 있을 것이다.
				
				이것을 해결하기 위해서 만들어진 VO 클래스가 Map.Entry 클래스이다.
				이 클래스는 내부에 key와 value라는 변수를 은닉화 시켜서 가지고 있는 클래스이다.
				데이터를 입력하는 함수와 채우는 함수도 만들어 놓았다.
				
	TreeMap
	==> TreeSet 과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다.
		이 때 정렬기준은 키값을 이용해서 정렬하게 된다.
		==> 따라서 키값이 크기 비교가 가능한 데이터여야만 입력된다.
		
		필요하면 TreeSet에서와 마찬가지로 정렬기준을 정해서 사용할 수 있다.
	
	참고 ] 
		컬렉션안에는 다시 컬렉션이 입력될 수 있다.
		왜? 컬렉션 안에는 모든 클래스를 입력할 수 있으므로 컬렉션도 클래스에 해당하기 때문에 입력할 수 있다.
								
		
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
			
			