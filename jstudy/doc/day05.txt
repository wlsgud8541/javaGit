# day05

자바 프로그램의 토큰 구분
==> 컴파일러는 토큰 단위로 번역을 시도한다.
	따라서 개발자는 컴파일러가 번역을 하는 토큰 구분을 해줘야 한다.
	이것이 ';'이라는 기호를 이용해서 구분하게 된다.
	
	우리가 습관적으로
		int a = 10;
	라고 마지막에 세미콜론을 추가한 이유가  토큰을 구분하기 위한 기호였기 때문이다.
	
	결론적으로 토큰은
	하나의 명령이 종료되었음을 알려주는 기호이다.
	
	만약 개발자가 토큰 구분을 하지 않으면 오류가 날 수 있다.
	
	예] int no1 = 10
	   int no2 = 20;
	   
	   ==> 컴파일러는 두 줄을 하나의 명령으로 인식해서 
	   	       처리를 시도할 것이고 이런 명령 형식은 존재하지 않으므로 에러가 발생하게 된다.
	   
	   ==> 수정
	   int no1 = 10; int no2 = 20;
	   
	   
	       참고] ;(세미콜론) 대신 {}(중괄호) 가 그 역할을 대신 할 수 있다.
	   
	       예 ]
	       if(조건식){
	       		내용
	       } // 이 부분에서 토큰이 발생하게 된다.
	       
	   참고 ] 정수형태의 문자열을 실제 정수로 변환시키는 방법은
	   		
	   		"123" ==> 출력하면 숫자처럼 보여지지만 실제 데이터의 형태는 문자열이다.
	   				  이 문자열을 숫자로 바꾸지 않는 이상 산술연산은 불가능하다.
	   				  
	   				이것을 실제 연산이 가능한 정수로 바꾸는 방법
	   				int no = Integer.parseInt("123");
	   				
	   				형식 ] int 변수이름 = Integer.parseInt("숫자형 문자열 데이터");
	   				
	   				
---------------------------------------------------------------------------------------------
컴퓨터가 숫자를 기억하는 방법
==> 몰라도 됨
	==> 몰라도 데이터를 입력하는 순간 컴퓨터가 알아서 기억해주기 때문에
	
		정수
			양의 정수
			==> 2진수로 변환하고 부호비트는 무조건 0을 붙인다.
			
			음의 정수
			==> 9의 보수법을 이용해서 처리한다.
				1) 양수로 가정하고 2진수로 변환
				2) 보수화 시킨다.(현재 숫자를 바꾼다. 0 -> 1, 1 -> 0)
	   			3) +1을 한다.
	   			4) 부호비트는 강제로 1로 지정한다.
	   			
	   			예] -20 의 경우
	   				1. 20을 양수로 가정하고 2로 나눈다.
	   				     나눌값   연산값   나머지
	   					2   20
	   					2	10	  0
	   					2	 5 	  0
	   					2	 2	  1	 
	   					2	 1	  0
							 0	  1
							 
					2. 2진법으로 변환하면 00010100
					3. 이 숫자를 int라고 생각하면
						int -> 4byte
						00000000 00000000 00000000 00010100		 		   				
					
					4. int로 표현한 값을 보수화(0은 1로 변환 / 1은 0으로 변환)
						11111111 11111111 11111111 11101011   				
	   				
	   				5.  11111111 11111111 11111111 11101011 값에 2진수로 변환 시킨 1을 더하면
	   					
	   						11111111 11111111 11111111 11101011 
	   					+									 +1
	   						------------------------------------									  	
	   				 		11111111 11111111 11111111 11101100	 =>  -20
	   	
	   	
	   	실수는 주어진 비트를 3영역(부호영역, 소수영역, 데이터영역)으로 나눈 후
	   	입력된 데이터를 지수형태의 데이터로 만들어서 각각의 영역에 기억되도록 하는 방식을 사용한다.			
	   	
	   	따라서 실수를 기억하는 방식을 소수점을 이동해서 기억한다는 의미에서 "유동 소수점" 방식이라고 표현한다.			
	   				
---------------------------------------------------------------------------------------------

연산자의 우선순위
==> 하나의 연산식에서 여러 연산자가 혼용되어서 사용되는 경우 어떤 것을 먼저 처리해야 될지를 정해 놓은 규칙
	
	규칙] 산술 -> 비교 -> 논리 -> 대입
	
	예] no > 10 & no < 20
	   의 경우 연산 방향대로 왼쪽에서 오른쪽으로 순차적으로 처리하지 않고

	   먼저 왼쪽에 있는 비교연산자를 연산하고
	   오른쪽의 비교연산자를 연산한 후
	   논리 연산자를 연산하게 된다.  
	  


---------------------------------------------------------------------------------------------

증감 연산자 
==> 주기억장치에서 직접 연산되는 연산자
	대입하지 않아도 변수 자체가 변경된다.
	
	기호 ]
		++
		--
		
	의미 ] 변수의 데이터를 1씩 증가(또는 감소) 시키세요.		   
	
	예 ] int no1 = 10;
		no1++;
		==> no1 : 아직은 10, 이 후에 오는 no1에  +1 해서 11로 기억   				
	   				
	   	int no2 = 20;
	   	--no2;
	   	==> -- 연산자 다음에 바로 no2가 오기때문에 no2를 -1 해서 19로 기억
	   	
	 주의] 이 연산자는 다른 연산자와 혼합되어 있는 경우
	 	 (연산을 해야하는 데이터가 다른 연산자(명령)에도 사용되는 경우)
	 	 (하나의 식 안에 다른 연산자와 증감연산자가 같이 있는 경우)
	 	  다른 연산자의 실행 순서가 달라질 수 있다.
	 	  즉, 증감 연산자가 먼저 실행 될 수 있고, 증감 연산자가 나중에 실행 될 수도 있다.  	
	 	 
	 	 예] b = ++a; 		
	 	 		1. a 라는 변수는 증감하세요.
	 	 		2. b 에 기억시키세요.	
	 	 	
	 	 	이 경우 a는 둘 중 무엇을 먼저 실행할지 구분해야 한다.
	 	 	
	 	 종류] 누구를 먼저 실행할지 명확하게 구분하기 위해서 규칙이 생겼다.
	 	 	 
	 	 	 1. 선처리 증감
	 	 	 	형식] ++데이터; 
	 	 	 		==> 증감을 먼저하고 다른 연산을 나중에 하세요.
	 	 	 	
	 	 	 2. 후처리 증감 		
	   			형식] 데이터++;	
	   				==> 다른 연산을 먼저 수행하고 증감 연산을 나중에 하세요.
	   				
---------------------------------------------------------------------------------------------

부호 반전 연산자
==> 현재의 부호를 반대로 바꿔주는 연산자
	즉, 현재 양수이면 음수로, 현재 음수이면 양수로 바꿔주는 연산자
	
	기호 ] -
	
	형식 ] -데이터;	   				
	   				
---------------------------------------------------------------------------------------------

비교 연산자
==> 두 데이터의 크기 관계를 비교하는 연산자
	기호 ] ==  같다
		 !=  다르다
		 >   크다
		 <   작다
		 >=  크거나 같다
		 <=  작거나 같다
			   				
	참고 ] 1. 사용되는 피연산자의 데이터에 관계없이 연산의 결과는 항상 논리값(true, false)이 발생한다.				
	   	 2. 이 연산자는 주로 if, ... 등의 제어명령에서 질문이 필요할 때 많이 사용되는 연산자이다.			
	
	****
	주의 ] 문자열은 기본 데이터 타입이 아니다.
		  따라서 문자열을 비교할 때 조심해서 사용해야 한다.
		 
		 문자열을 기억할 때는
		 	new String("문자열데이터") 의 형식으로 하면 Heep에 기억이되고
		 	String str = "문자열데이터" 의 형식으로 하면 리터럴 풀에 기억하게 된다.
		 	
		 	리터럴 풀의 특징]
		 		1. 주소를 알아야 사용 할 수 있다.
		 		2. 개발자가 입력한 데이터는 반드시 리터럴 풀에 저장되어진다.
		 		3. 리터럴 풀은 같은 데이터가 입력되면 저장하지 않고 먼저 입력된 데이터를 재사용하게 된다.
		 	
		  
		  동등비교의 경우 데이터를 비교하는 것이 아니고
		  주소를 비교하는 개념이다.
		  
		 문자열의 경우 데이터의 비교가 필요한 경우는
		 String 클래스 소속의 equals() 함수를 이용해서 비교해야 한다.
		 
		 참고 ] 산술 연산이 가능한 데이터는 자바에서는 기본형 데이터(논리형 제외)에서만 가능하다.
		
---------------------------------------------------------------------------------------------
논리 연산자
==> 두 논리값(true 또는 false) 사이의 관계를 따지는 연산자
	==> 즉, 논리값을 AND, OR, NOT 방식으로 관계를 알아보는 연산자
	
	주의사항 ] 데이터(두 개의 피연산자)는 반드시 노리값이어야 한다.
	
	기호 ] !  NOT 연산(단항 연산자)
		 &  AND 연산(이항 연산자)
		 |  OR 연산(이항 연산자)
		 && AND 절삭연산(이항 연산자)
		 	==> AND 연산의 경우 두 개의 피연산자가 모두 TRUE 인 경우에 한해서만 TRUE
		 		따라서 앞의 피연산자(데이터)가 FALSE일 경우 뒤의 데이터가 무엇이 오던지 상관없이 항상 FALSE가 된다.
		 		따라서 이런 경우는 뒤의 데이터를 읽어보지 않아도 결과는 결정이 된 상태이므로
		 		이런 경우 뒤의 결과를 읽어보지도 않는 절살 AND 연산을 하게 되는 연산자가 '&&'연산자이다. 
		 ||	OR 절삭연산(이항 연산자)	   		
			==> 앞의 데이터가 TRUE면 뒤에 데이터에 상관 없이 TRUE
				따라서 뒤의 데이터를 읽어보지도 않는 연산자가 '||' 연산자이다.
				
	참고 ] 컴퓨터는 한번에 하나의 질문만 처리 할 수 있다.
		  즉, 크면 큰거고 작으면 작은거다.
		 이 말은 어떤 범위의 비교를 하자의 연산으로 할 수 없다.
		 
		 예 ]
		 	수학의 경우
		 		10 < no1 < 20
		 	의 연산이 가능하지만
		 	
		 	컴퓨터 연산의 경우는 한번에 하나만 처리하기 때문에 불가능하다.
		 	따라서, 
		 		no1 > 10 & no1 < 20
		 	로 표현해야 한다.
		 	
	결론 ] 논리 연산자의 연산 결과는 논리값이 나와야 한다.
	
---------------------------------------------------------------------------------------------	
		 						
비트연산자
==> 자바에서는 잘 사용하지 않는 연산자이다.
	C언어에서 가지고 온 연산자로	           
	C언어의 경우는 메모리 주소에 직접 접근이 가능하고 이용할 수도 있는 것이므로
	이런 경우 필요했던 연산자이다.
	자바의 경우는 메모리에 직접 접근이 불가능하기 때문에 사용하지 않는 연산자 이다.
	
	비트 연산자란?
		숫자를 비트단위로 저장된 상태를 이용해서
		각 비트마다 따로 연산을 하는 연산자,
	
	기호 ]
		&	비트 AND
		|	비트 OR
		^	비트 XOR
		
	이 연산자는 가끔 시험 문제로 출제가 되기도 하는데
	논리 연산자와 구분하는 방법은 
	
	피 연산자가 숫자면 비트연산자로 처리해주면 된다.
	
		예] 10 & 20
	
	참고 ] 비트 연산의 결과는 항상 숫자로 나온다.
		 
		 ~ 보수화 연산자(단항 연산자)
		 	==> 각각의 비트의 숫자를 반대로 바꿔주는 연산자.
		 	
---------------------------------------------------------------------------------------------	
			 		            	
쉬프트 연산자

	기호 ]
		>>
		<<
			            	
	의미 ] 각각의 비트를 지정한 방향으로 지정한 숫자만큼 이동시켜주는 연산자
	
	예 ] int a = 10;
		
		int b = a << 2;
		
			10을 비트로 만들면
				1010
			비트를 왼쪽으로 2칸 밀면
				0010 1000
			십진수로 바꾸면
				40
			이 된다.		              	
	            	
	    int b = a >> 2;        	
	         
	        비트
	        1010
	        비트를 오른쪽으로 2칸 밀면
	        0010       	
	        십진수로 변환하면 
	        2        	
	        결과적으로
	        10 / 2^2
	        
	    
---------------------------------------------------------------------------------------------	
대입 연산자
	==> 변수에 데이터를 기억시키기 위한 연산자
		
		주의 ] 연산된 결과는 대입연산자를 거치지 않으면 변수에 기억되지 않는다.
		
		기호 ] =
		
		형식 ] 변수 = 데이터;
				여기서 데이터는 	상수(입력한 내용, 리터럴 데이터)
							연산식(연산 수행결과를 변수에 대입한다는 의미)
							변수
							
		예] 
			a = 10;
			a = 10 << 2;
			a = b;
			
		참고]
			누적 대입연산자
			==> 특정 변수에 연산을 한 후에 다시 그 변수에 결과를 기억하는 경우에는(누적 대입에 해당하는 경우)
				
				예 ] a = a + 10;
				
				의 연산식을 줄여서 사용 할 수 있다.
				
				형식 ]
					변수	연산자 =	제이터;
					<==	변수	= 변수 	연산자	데이터;
					
				예 ]
					a = a +10;
					==> a += 10;
					
					a = a >>3;
						a >>= 3;
			
			참고 ] 1.실무에서는 될 수 있으면 이 방식을 선호하지는 않는다.
				       실무에서는 원래 원칙대로 사용하는 것이 좋다.
				       
				 2.대입연산자의 연산 방향은 오른쪽에서 왼쪽으로 진행한다.
															    
				    
---------------------------------------------------------------------------------------------	
3항 연산자(3항 조건 연산자)	    
==>	연산자라기 보다는 하나의 명령에 가까운 형식을 가지고 있는 연산자
	조건에 따라서 처리할 내용을 구분해서 처리하도록 하는 연산자.
	
	형식 ] 변수 = (조건식) ? 조건식이 참인경우 반환값 : 조건식이 거짓인경우 반환값
	
	의미 ] 조건식이 참이면 참인경우 반환값을 반환해주고 거짓이면 거짓인 경우 반환값을 반해준다.
	
	주의 ] 조건식은 반드시 참 또는 거짓의 결과가 만들어져야 한다.
		 if 명령을 단순화 시켜놓은 명령이다.
	
	참고 ] 모든 연산자가 중첩 처리 되듯이
		 조건 연산자도 중첩 처리 될 수 있다.
		 
		 예] (조건식1) ? 데이터1 : ((조건식2) ? 데이터2 : 데이터3);
		 	
		 	   
	    
	    
	    
	    
	    
	            	
	            	
	            	
	            	
	            	
	            	
	            	
	            	
	            	