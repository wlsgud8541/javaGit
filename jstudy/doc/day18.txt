# day18

JDBC
==> 자바 프로그램을 이용해서 데이터베이스를 컨트롤 할 수 있는 외부 API이다.

	데이터베이스는 그 데이터베이스가 가진 DBMS에 의해서 성능이 결정된다.
	각각의 데이터베이스마다 질의 명령을 처리하는 방법(DBMS)이 다르다는 것이 된다.
	따라서 개발자 입장에서 보자면
	데이터베이스마다 그 데이터베이스의 DBMS에 따라서 프로그램 방식을 다르게 해야 한다는 것이 된다.
	
	그래서 해결방법으로
	자바 안에 DBMS를 만들어 놓고 
	개발자는 자바의 DBMS에게만 명령을 전달하도록 해 놓았다.
	==>
		개발자는 한 가지 방식으로만 처리하도록 되었다.
	자바 안에 있는 DBMS가 실제 데이터베이스와 연결해서 처리하도록 해 놓았다.
	
	이때 자바 DBMS가 바로 JDBC 이다.
	
	따라서
	우리가 JDBC를 배운다는 것은
	우리는 JDBC에게만 명령을 전달하면(한가지 방식으로 명령을 전달하면)
	JDBC가 알아서 필요한 데이터베이스의 DBMS에게 명령을 전달 하게 된다.
	
	참고 ] JDBC와 각 밴더 DBMS를 연결하는 프로그램은 
		   그 데이터베이스를 만든 회사에서 제공한다.
		   
***
자바 개발자(데이터베이스 처리를 해야하는 개발자)가 가장 먼저 해야할 일
	
	1. 사용하려는 데이터베이스와 JDBC를 연결하는 프로그램을 찾아야 한다. 이 프로그램을 'JDBC Driver' 라고 부른다.
	
	2. 찾아낸 외부 API를 이클립스에 등록해서 이클립스에서 외부 API를 사용 할 수 있도록 해야한다.	 		   
	   (외부 라이브러리 등록 방법)
			1) 해당 프로젝트의 프로젝트 속성 창(Properties) 으로 들어간다.
			2) 왼쪽 메뉴에서 Java Build Path 메뉴를 선택한다.
			3) 탭 메뉴 중 Libraries 를 선택한다.
			4) Add External JARs 버튼을 클릭해서 다운로드 받은 드라이버파일을 선택해준다.
		
			참고 ] 드리이버의 함수를 인터페이스로 만들어 놓은 이유
					==> 세션을 관리하는 방법이 각각의 DBMS마다 다르기 때문에 접속하는 순간 함수의 기능을 각각의 DBMS에 맞도록 조절해야하기 때문이다.
					
					
	JDBC 프로그램 정리 ] 				  
		0. JDBC 드라이버를 구한다.
		
		1. 드라이버를 로딩한다. 
			(예 ] SmartJDBC CLASS 내의 Class.forName())
			
		2. 데이터베이스에 접속을한다. 
			( Connection con = DriverManager.getConnection(); <== getCon() )
			
		3. JDBC와 실제 DBMS 사이에 명령을 전달 할 수 있는 도구를 만들어야 한다.
	   		(
	   			오라클은 데이터베이스 서버이다.
	   			즉, 프로그램이 동작하는 컴퓨터와 데이터베이스가 있는 컴퓨터는 다를 수 있다.
	   		)

			사용하는 인터페이스
				Statement
			
			만드는 방법
				Statement stmt = con.createStatement();
				
				참고 ] 질의명령을 실행하는 방법(Statement에 질의명령을 실어서 보내는 방법)
					
						1. execute(String sql)
							==> 질의명령을 실행 후 JDBC에게 보고 하지 않는다.
								반환값 타입은 boolean 타입인데
								이것은 질의실행여부를 알려주는 기능이 아니고
								데이터베이스가 JDBC에게 명령을 받았는지만 알려준다.
								
								이 반환값은 질의 실행 여부와는 전혀 상관이 없는 반환값이다.
							
						2. executeQuery(String sql)
							==> 반환값타입이 ResultSet
								ResultSet이란? ==> 질의명령 실행 결과 탄생하는 인라인 테이블을 관리하는 클래스
								
								100% SELECT 질의명령에 사용되어진다.
							
							
						3. executeUpdate(String sql)	
							==> 반환값타입이 int
								반환값타입의 의미는 질의명령 실행결과
								변경된 행의(데이터) 숫자
								
								예] - UPDATE를 했는데 몇 개의 행이 변경 되었는지
									- DELETE를 했는데 몇 개의 행이 삭제 되었는지
									- INSERT를 했는데 몇 개의 행이 추가 되었는지

								주로 질의명령의 실행 결과 여부를 판단해야 할 경우에 사용하는 함수
									
									INSERT, UPDATE, DELETE
						
						참고 ] 질의명령은 위 세 함수를 아무것이나 사용해도 상관없다. 			

-----------------------------------------------------------------------------------------------------------------------------------------

SELECT 질의결과 사용하기

	JDBC에서 SELECT 질의명령을 보내면 그 결과 인라인 테이블이 생성이 되고
	ResultSet 이라는 인터페이스 타입의 객체가 그 결과를 관리하도록 하고 있다.
	
	ResultSet이라는 인터페이스를 이용해서 인라인테이블의 결과 중에서 필요한 데이터를 선택해서 사용 할 수 있게 된다.
	
	인라인 테이블의 결과 중에서 원하는 데이터를 꺼내는 방법은 
	
	현재 작업줄(행, ROW)의 몇번째 칸 또는 어떤 어떤 칸(필드이름, 필드, 속성, 칸)을 꺼내달라고 요청해야한다.
		작업 진행줄 : 레코드포인터 라고 말한다.
		
	주요함수 ]
	
		1. 가상의 레코드 포인터(현재 작업 위치)를 이동시켜주는 명령
			
			absolute(int row)
			==> 지정한 행으로 즉시 이동
			
			afterLast()
			==> EOF 로 즉시 이동
			
			beforeFirst() 
			==> BOF 로 즉시 이동
			
			first()
			==> 첫 행으로 즉시이동
			
			last()
			==> 마지막 행으로 즉시 이동
			
			next()
			==> 현재위치의 다음 행으로 이동, 반환값 타입은 boolean(의미는 이동 결과 꺼낼 데이터가 있는지 여부)
			
	
			주의 ] 
				afterLast()		==> EOF
				beforeFirest()	==> BOF
				==> 항상 이동에 성공하게 된다. 		
					EOF, BOF는 인라인테이블이 새성되면
					자바가 자동으로 만들어주는 가상의 위치이므로
					언제나 존재한다.
				
				이들 함수 이외의 함수들은 이동에 실패 할 수 있다.
		
		
		2.	데이터를 꺼내는 함수
			==> 실제 데이터베이스에 있는 타입이 아니고
				그 데이터를 사용 할 자바에서의 타입을 이야기한다.
				==> 데이터베이스에 있는 타입과 달라도 상관없다.
	
			getXXXXX()
			==> XXXXX는 꺼낼 데이터를 사용 할 데이터 타입을 의미
			
				참고 ] 
					getChar() 라는 함수는 존재하지 않는다.
						==> 데이터베이스에서는 문자와 문자열을 구분하지 않기 때문이다.
	
			주의]
				꺼내는 방식
					1. getXXXXX(int 컬럼위치)	
						==> 질의명령에서 나열된 필드의 위치 값을 사용하는 방식
						
							자바는 위치값(인덱스)이 0부터 시작하지만
							데이터베이스는 위차값(인덱스)가 1부터 시작한다.
							
							예 ]
								SELECT EMPNO
									 , ENAME
									 , JOB
								FROM EMP;
									
								==>
									getString(3); ==> job 꺼내는 방법
								
					2. getXXXXX("필드이름")
								==>
									getString("JOB"); ==> 필드이름으로 꺼내는 방법 
									
									별칭이 붙은경우는 인라인테이블의 필드이름이
									별칭으로 만들어지기 때문에 별칭으로 꺼내야 한다.
									
									SELECT EMPNO
									 , ENAME
									 , JOB jikgeop
									FROM EMP;
									
									==> getString("jikgeop");
									
					주의 ]
						Date 타입 데이터는 꺼내오는 함수를 JDBC에서
						날짜만 꺼내는 함수와 시간만 꺼내는 함수로 만들어 놓았다.
						따라서 정확한 날짜 데이터를 꺼내려면
						한 필드에서 날짜와 시간을 각각 꺼내와야 한다.
						
							날짜 - getDate("필드이름");
							시간 - getTime("필드이름");
										
-----------------------------------------------------------------------------------------------------------------------------------------

양방향 이동가능한 인라인 테이블 만드는 방법
==>
	Statement가 양방향 Statement가 되어야 한다.
	
	createStatement(int resultSetType, int resultSetConcurrency)
	를 이용해서 Statement를 만들어야 양방향 인라인테이블이 만들어 질 수 있다.
	
	--------------------------------------------------------------------------
		
		int resultSetType
			
			ResultSet.TYPE_FORWARD_ONLY
			==> 정방향 인라인테이블을 만들어 준다.
			
			ResultSet.TYPE_SCROLL_INSENSITIVE
			==> 양방향 인라인 테이블을 만들어준다. 	
				저장된 데이터를 반복해서 작업하는 동안
				누군가 데이터를 변경하면 변경을 적용시키지 않는다.
				
			ResultSet.TYPE_SCROLL_SENSITIVE
			==> 양방향 인라인테이블을 만들어준다.
				데이터의 변경을 적용시킨다.
				
	--------------------------------------------------------------------------
		
		int resultSetConcurrency - 동시성 설정				
		
			ResultSet.CONCUR_READ_ONLY
			==> ResultSet의 데이터를 읽기 전용으로 업데이트가 불가능하도록 하는 설정
			
			ResultSet.CONCUR_UPDATABLE
			==> 업데이트 가능	
				
			
	참고 ] JDBC는 UPDATE, DELETE, INSERT 명령을 실행하지 않고도
		   직접 데이터를 수정 할 수 있다.

		   
---------------------------------------------------------------------------------------------------------------------------------------
		   			
PreparedStatement
==> 질의명령을 데이터베이스에 전달하는 Statement의 일종이다.
	
	Statement의 단점은
	질의명령을 실행 할 때마다 매번 질의명령을 데이터베이스에게 전달하는 형식을 취하는데
	질의명령이 긴 경우도 존재한다.
	데이터베이스는 네트워크를 이용하고 있고 따라서 명령전달을 하는데 시간이 걸리는 등 문제가 발생하게 된다.
	
	이런 문제점을 해결하기 위한 Statement가 PreparedStatement이다.
	이것은 미리 질의 명령을 알려준 후 실행이 필요하면 실행만 해달라고 요청하는 형식이다.
	
	만드는 방법 ]
		con.prepareStatement();
		
	참고 ]
		자주 사용하는 질의명령이라도 데이터는 달라질 수 있다.	
		이런 경우는
		질의 명령을 만들 때 변화되는 부분은 ? 로 대신하면 된다.
		
		? 부분만 질의명령을 보내기 전에 직접 데이터로 채워서
		질의명령을 완성한 후 전달하는 방식
		
	예 ]
		회원의 아이디를 알려주면 메일을 알려주는 질의명령
		==>
			String SQL = SELECT MAIL FROM MEMBER WHERE ID = ?
			
			PrepareStatement pstmt = con.prepareStatement(sql);
			
	주요함수 ]
		? 채워주는 함수
		
		setXXXXX(위치, 데이터);
			
			XXXXX  : 채울 데이터의 형태에 따라서 달라진다.
			위치   : ? 의 위치 <== 몇번재 ? 인지를 기술
			데이터 : 채울 데이터			
			
			==> 
			예 ] pstmt.setString(1, "jennie");
		
		참고 ] Statement는 속도는 느리지만 매번 다른 질의명령을 처리 할 수 있다.
			   PreparedStatement는 속도는 빠르지만 항상 동일한 질의명령만 처리 할 수 있다. 
			
			
==========================================================================================================================================

StringBuffer
==> String 클래스와 마찬가지로 문자열을 관리하는 클래스

	*****
	차이점
		String 은 내용이 변환되면 새로운 메모리를 다시 확보하고 
		변화된 내용은 다시 기억한 후 주소를 바꾼다.
		==> 자주 변화가 일어나면 메모리 낭비가 심해진다.
		
		StringBuffer는 String의 문제점을 해결하기 위해서 만들어 놓은
		또 하나의 문자열 관리 클래스로
		내용의 변화가 있으면 현재 메모리에 변화된 내용을 그대로 기억한다.
		
	참고 ]
		String str = "홍";
		==> String 은 너무 빈번하게 사용되는 클래스이므로
			클래스들 중 유일하게 데이터를 직접 대입 할 수 있도록
			자바가 유일하게 허락한 문법이다.

		StringBuffer는 String 클래스와는 달리 대입연산자(=)를 이용해서
		문자열을 기억하는 것이 불가능하다.
		객체지향 원리에 따라서 반드시 new 시켜서 사용해야한다.
		
		예 ] 
			StringBuffer buff = "jennie";  <== 불가능 
			StringBuffer buff = new StringBuff("jennie"); <== 가능
			
	참고 ]
		String str = "Hong";
		str = str + "Gilong";		
	
		즉, 결합연산자(+)를 이용한 문자열을 결합하는 것 역시
		String 클래스에 한해서만 허락된 문법이다.
		
		나머지 클래스는 반드시 그 클래스가 가진 기능(함수)를 이용해서
		필요한 처리를 해줘야 한다.
		
		StringBuffer buff = new StringBuffer("Hong");
		buff.addend("GilDong");
		
	사용하는 방법 ]
	
		1. String 이 편하므로 String으로 변수를 만든다.
			==> String str = "Hong";
				
		2. 문자열 변화가 필요한 시점에서 StringBuffer로 변환시켜준다.
			==> StringBuffer buff = new StringBuffer(str);
		
		3. StringBuffer 를 이용해서(내부의 함수를 이용해서) 문자열을 조작한다.
			==> 메모리의 낭비가 줄어들게 된다.
			
			buff.append("Gil");
			buff.append("Dong");
			
		4. 문자열의 조작이 완료되면 다시 편하게 사용 할 수 있는 String 타입으로 변환시켜 놓아야 한다.
			==> str = buff.toString();					

		참고 ]
			StringBuilder
			==> 이 클래스 역시 StringBuffer와 동일한 역할을 하는 클래스이다.
				주로 Thread(쓰레드)처리를 할 때 동기화에 대해서 안정적으로 처리가 가능하다.
				
				
--------------------------------------------------------------------------------------------------------------------------------------------
StringTokenizer
==> 하나의 문자열을 원하는 문자를 중심으로 나누어주는 기능을 가진 클래스
	
	네트워크 등을 이용하면 여러개의 데이터가 한번에 동시에 전달받게 된다.
	
	예를 들자면
		카톡의 경우
		카톡을 보낸사람, 보낸시간, 내용, ...이
		하나의 문자열로 구성되어서 한번에 들어오게 된다.
		
		==> 이런 경우에 각각의 데이터를 분리해서 처리해야 한다.
			보낸사람@보낸시간@내용
	

	생성자 ]
		1. StringTokenizer(String str)
			==> 문자열(str)을 공백을 구분자로 나누는 기능
			
		2. StringTokenizer(String str, String delim)
			==> 문자열(str)을 지정한 문자열(delim) 기준으로 나누는 기능
			
		3. StringTokenizer(String str, String delim, boolean returnDelims)
			==> 문자열(str)을 지정한 문자열(delim) 기준으로 나누는 기능 + 기준 문자(delim)도 하나의 문자로 처리한다.
			
		주의 ]
			분리된 결과는 임시 버퍼(스택)에 기억된다.
			따라서 이것은 한번 사용하면 더 이상 사용 할 수 없게 된다.
			반드시 순서대로만 꺼내야한다.	

	주요함수 ]
		countTokens()
		==> 나눈 결과 수를 반환
		
		hasMoreElements() / hasMoreTokens()
		==> 버퍼에 꺼낼 데이터가 남아있는지를 붇는 함수

		nextElement()
		==> 데이터를 꺼내는 함수, Object 타입으로 꺼내준다.
		nextToken()
		==> 데이터를 꺼내는 함수. String 타입으로 꺼내준다.


=======================================================================================================================================

컬렉션

	배열을 이용해서도 많은 양의 데이터를 보관 할 수 있지만
	배열의 단점은
		1. 크기를 변경하지 못한다.
			( 한번 데이터의 양을 결정해서 배열을 만들면
				그 보다 많은 양의 데이터를 보관 할 수 없다.)
		2. 데이터의 입출력에 많은 제약을 받는다
			==> 반드시 위치를 알아야 입출력이 가능하다.
		
		이런 단점을 보완하고자 만들어진 클래스들이 컬렉션이다.
		
	종류 ] 
		1. List 계열
			==>
				특징 ]
					1) 입력순서를 보장한다.(처리속도가 느리다.)			
					2) 중복데이터의 입력을 허락한다.
		
		2. Set 계열			
			==> 
				특징 ]
					1) 입력순서를 보장하지않는다.
						(나름의 규칙에 의해서 데이터를 정렬해서 보관한다.)
					2) 중복데이터의 입력을 허락하지 않는다.
						==> 중복 데이터는 한번만 저장한다.
				
				참고 ]
					Set 계열은 데이터를 꺼내는 함수가 존재하지 않는다.
						
		---------------------------------------------------------------------
		3. Map 계열
			==>
				특징 ]
					1) 데이터를 그 데이터를 구분하는 키값과 한쌍을 만들어서 저장한다.
					2) 입력순서는 보장하지 않는다.
					3) 같은 키값으로 데이터 입력되면 이전 입력된 데이터는 삭제한다.
						(즉, 데이터는 중복이 되어도 상관없지만
							키값은 중복되어서 입력될 수 없다.)				


	참고 ] 
		List 계열과 Set 계열은 같은 상위 클래스를 가지고 있다.
		Map 계열은 사우이 클래스가 다르다.
		따라서 List계열과 Set계열은 다형성 처리가 가능하지만
		(서로 형변환이 가능하다.)
		Map 계열은 독립적이므로 변환이 불가능하다.
				
=======================================================================================================================================

List 계열
1. Vector
	==> 내부적으로 배열형태를 만들어서 데이터를 보관하는 컬레겻ㄴ의 일종
		
		장점 ]
			입력속도와 검색 속도가 빠르다.	
		
		단점 ]
			중간에 데이터를 삽입하거나 데이터를 삭제하는 속도는 느리다.
			
		결론 ]
			결론적으로 데이터의 변화가 거의 없는 프로그램에서 많이 사용된다.
		
		생성자 ]
		
			1) Vector()
				==> 배열의 크기를 10으로 정한 상태로 벡터를 만들어 준다.
					물론 데이터가 배열의 크기보다 많으면 크기는 기존 크기의 2배로 변경이 된다.
			
			2) Vector(Collection c)
				==> 다른 컬렉션 데이터를 복사해서 벡터를 만들어준다.
				
			3) Vector(int initialCapacity)
				==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만든다.
			
			4) Vector(int initialCapacity, int capacityIncrement)		
				==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만들고
					데이터의 양이 초과될 때 늘어나는 크기를 정하면서 벡터를 만든다.
	
		참고 ]
			컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력 받을 수 있다.
			이때 데이터를 입력 받을 공간을 확보해야 하는데 
			공간을 확보하는 규칙은
				현재공간 * 2
			로 확보를 하게 된다.	
	
		주요함수 ] 
			1. 데이터를 입력하는 함수
				add(Object e) 
					==> 매개변수가 Object 타입임으로 입력 데이터는 Object타입으로 자동 형변환 된다.
						==> 다라서 자바에서 사용하는 모든 데이터를 입력 할 수 있다.
				
				add(int index, Object element)
					==> 입력 될 위치를 정해서 입력
					
				add(Collection c)
				
				add(int index, Collection c)
				
				addElement(Object obj)
				
				addElement(Object obj, int index)
							
			2. 데이터를 꺼내는 함수
				get(int index)
				
				elementAt(int index)
				
				firstElement()
				
				LastElement()
				
				elements
				
			
			3. 데이터를 수정하는 함수
				set(int index, Object element)
				setElementAt(Object obj, int index)
				
				
	참고 ] 
		E, V, K 라고 표현되어 있는 것을은 Object를 의미하는 제네릭스 용어이다.
			
-----------------------------------------------------------------------------------------------
ArrayList
==> Vector의 신버전
	배열 형태로 데이터를 관리하기 때문에 Vector의 특징을 그대로 가지게 된다.
	다만, 쓰레드(Thread)처리에서 동기화 처리를 자동으로 해줌으로
	Vector보다는 ArrayList를 선호하는경향이 있다.
	
	사용방법 역시 Vector 와 유사하다.
	
	참고 ]
		List 계열의 주소를 출력하면 마치 데이터가 출력되는 것처럼 보인다.
		하지만 이것은 해당 클래스에서 Object 클래스에서 상속 받은
		toString()함수를 오버라이딩 해놓았기 때문에 내용을 출력해주는 것이다.
		즉, 데이터를 꺼내온 것이 아닌 상태다.
		
		List 계열을 사용할 때는 반드시반복문으로 하나씩 꺼내서 사용해야 된다.
		 		
		
		
		
		
		
		
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


	
	
	
	
	
	
	
	
	
	
	
	
	